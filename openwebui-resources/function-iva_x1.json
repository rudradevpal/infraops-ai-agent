[{"id":"iva_x1","user_id":"93fe113e-bf85-468c-a111-20a862fc09a3","name":"iva - x1","type":"pipe","content":"\"\"\"IVA Pipe Function for OpenWebUI.\n\nThis module provides a connector between Open-WebUI and IVA workflows.\n\ntitle: IVA Pipe Function\nauthor: Rudradev PAL (fork from https://openwebui.com/f/coleam/n8n_pipe)\nauthor_url: https://github.com/rudradevpal\nversion: 0.5\n\"\"\"\n\nimport base64\nimport io\nimport logging\nimport time\nfrom typing import Any, Awaitable, Callable, Dict, Optional, Union\nfrom urllib.parse import urljoin\n\n# Add type stubs for missing libraries\ntry:\n    import httpx\n    from pydantic import BaseModel, Field, field_validator\nexcept ImportError:\n    # For type checking only\n    pass\n\n\n# Configure logger\nlogger = logging.getLogger(__name__)\n\n\nclass Pipe:\n    \"\"\"N8N Pipe connector for Open-WebUI.\n\n    This class implements an asynchronous connector between Open-WebUI\n    and n8n workflows for redirecting chat messages.\n    \"\"\"\n\n    class Valves(BaseModel):\n        \"\"\"Configuration parameters for the N8N Pipe connector.\"\"\"\n\n        workflow_url: str = Field(\n            default=\"http://infra-workflow:5678\",\n            description=\"Base URL for IVA workflow server (without trailing slash)\",\n        )\n        model_version: str = Field(\n            default=\"iva-tryme-x1\",\n            description=\"Model version of IVA workflow model\",\n        )\n        workflow_test_mode: bool = Field(\n            default=False,\n            description=\"Whether to use test mode URLs for n8n webhooks\",  # NOQA\n        )\n        workflow_bearer_token: str = Field(\n            default=\"your-token-here\",\n            description=\"Bearer token for n8n authentication\",  # NOQA\n        )\n        input_field: str = Field(\n            default=\"chatInput\",\n            description=\"Field name for the input in the JSON payload\",\n        )\n        response_field: str = Field(\n            default=\"output\",\n            description=\"Field name for the output in the response JSON\",\n        )\n        emit_interval: float = Field(\n            default=2.0,\n            description=\"Interval in seconds between status emissions\",  # NOQA\n        )\n        enable_status_indicator: bool = Field(\n            default=True,\n            description=\"Enable or disable status indicator emissions\",  # NOQA\n        )\n        timeout: float = Field(\n            default=120.0, description=\"Timeout for HTTP requests in seconds\"\n        )  # NOQA\n        max_retries: int = Field(\n            default=2,\n            description=\"Maximum number of retries for failed requests\",  # NOQA\n        )\n\n        @field_validator(\"workflow_url\")\n        @classmethod\n        def validate_host_url(cls, v: str) -> str:\n            \"\"\"Validate that the n8n host URL includes a protocol.\n\n            Args:\n                v: The URL to validate\n\n            Returns:\n                The validated URL if it passes validation\n\n            Raises:\n                ValueError: If the URL does not start with http:// or https://\n            \"\"\"\n            if not v.startswith((\"http://\", \"https://\")):\n                raise ValueError(\n                    \"workflow_url must start with http:// or https://\"\n                )  # NOQA\n            return v\n\n    def __init__(self) -> None:\n        \"\"\"Initialize the N8N Pipe connector.\"\"\"\n        self.type = \"pipe\"\n        self.id = \"n8n_pipe\"\n        self.name = \"N8N Pipe\"\n        self.valves = self.Valves()\n        self.last_emit_time: float = 0.0\n        self._http_client = httpx.AsyncClient(timeout=self.valves.timeout)\n        logger.info(f\"Initialized {self.name}\")\n\n    async def __aenter__(self) -> \"Pipe\":\n        \"\"\"Async context manager entry method.\n\n        Returns:\n            Self, for use in async with statements\n        \"\"\"\n        logger.debug(\"Entering async context\")\n        return self\n\n    async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:  # NOQA\n        \"\"\"Async context manager exit method, closes the HTTP client.\n\n        Args:\n            exc_type: Exception type, if an exception was raised\n            exc_val: Exception value, if an exception was raised\n            exc_tb: Exception traceback, if an exception was raised\n        \"\"\"\n        logger.debug(\"Exiting async context\")\n        await self._http_client.aclose()\n\n    async def emit_status(\n        self,\n        __event_emitter__: Optional[Callable[[dict], Awaitable[None]]],\n        level: str,\n        message: str,\n        done: bool,\n    ) -> None:\n        \"\"\"Emit status update if conditions are met.\n\n        Args:\n            __event_emitter__: Callable to emit status events\n            level: Status level (info, warning, error)\n            message: Status description\n            done: Whether this is a completion status\n        \"\"\"\n        if not __event_emitter__:\n            return\n\n        current_time = time.time()\n        if self.valves.enable_status_indicator and (\n            current_time - self.last_emit_time >= self.valves.emit_interval\n            or done  # NOQA\n        ):\n            logger.debug(f\"Emitting status: {level} - {message}\")\n            await __event_emitter__(\n                {\n                    \"type\": \"status\",\n                    \"data\": {\n                        \"status\": \"complete\" if done else \"in_progress\",\n                        \"level\": level,\n                        \"description\": message,\n                        \"done\": done,\n                    },\n                }\n            )\n            self.last_emit_time = current_time\n\n    def get_webhook_url(self) -> str:\n        \"\"\"Build the n8n webhook URL based on configuration settings.\n\n        Returns:\n            Complete webhook URL with appropriate path for test\n            or production mode\n        \"\"\"\n        base_url = self.valves.workflow_url.rstrip(\"/\")\n        webhook_id = self.valves.model_version\n        path = (\n            f\"/webhook-test/{webhook_id}\"\n            if self.valves.workflow_test_mode\n            else f\"/webhook/{webhook_id}\"  # NOQA\n        )\n        return urljoin(f\"{base_url}/\", path.lstrip(\"/\"))\n\n    def _extract_question(self, content: Union[str, list]) -> str:\n        \"\"\"Extract the actual question from the content.\n\n        Args:\n            content: The message content to process, either a string or a list\n\n        Returns:\n            The cleaned question string\n        \"\"\"\n        # Handle case when content is a list (e.g., when images are attached)\n        if isinstance(content, list):\n            text_parts = []\n            for item in content:\n                if item.get(\"type\") == \"text\" and \"text\" in item:\n                    text_parts.append(item[\"text\"])\n            content = \" \".join(text_parts)\n\n        # Handle string content\n        if isinstance(content, str):\n            return content.split(\"Prompt: \")[-1] if \"Prompt: \" in content else content\n\n        return \"\"  # Return empty string if content is neither string nor list\n\n    def _create_session_id(\n        self,\n        user: Optional[Dict[str, Any]],\n        first_message: Optional[Union[str, list]],\n    ) -> str:\n        \"\"\"Create a session identifier for the n8n workflow.\n\n        Args:\n            user: User information if available\n            first_message: The first message in the conversation\n\n        Returns:\n            A session identifier string\n        \"\"\"\n        user_id = user[\"id\"] if user and \"id\" in user else \"anonymous\"\n        message_prefix = \"\"\n\n        if first_message:\n            # Clean and truncate the first message\n            clean_message = self._extract_question(first_message)[:100]\n            message_prefix = f\" - {clean_message}\"\n\n        return f\"{user_id}{message_prefix}\"\n\n    async def _handle_http_error(\n        self,\n        error: Exception,\n        __event_emitter__: Optional[Callable[[dict], Awaitable[None]]],\n    ) -> Dict[str, str]:\n        \"\"\"Handle HTTP and other errors uniformly.\n\n        Args:\n            error: The exception that was raised\n            __event_emitter__: Callable to emit status events\n\n        Returns:\n            Error response dictionary\n        \"\"\"\n        error_msg = str(error)\n        logger.error(f\"Error in n8n pipe: {error_msg}\")\n\n        await self.emit_status(\n            __event_emitter__,\n            \"error\",\n            f\"Error during sequence execution: {error_msg}\",\n            True,\n        )\n\n        return {\"error\": error_msg}\n\n    async def pipe(\n        self,\n        body: Dict[str, Any],\n        __user__: Optional[Dict[str, Any]] = None,\n        __event_emitter__: Optional[Callable[[dict], Awaitable[None]]] = None,\n        __event_call__: Optional[Callable[[dict], Awaitable[dict]]] = None,\n    ) -> Union[Dict[str, str], str, Any]:\n        \"\"\"Process the incoming request and return the response from N8N.\n\n        Args:\n            body: Request body containing messages\n            __user__: User information (optional)\n            __event_emitter__: Callable to emit status events\n            __event_call__: Callable for event calls\n\n        Returns:\n            N8N response or error dictionary\n        \"\"\"\n        await self.emit_status(\n            __event_emitter__, \"info\", \"Processing...\", False\n        )  # NOQA\n\n        messages = body.get(\"messages\", [])\n\n        # Check if messages list is empty\n        if not messages:\n            await self.emit_status(\n                __event_emitter__,\n                \"error\",\n                \"No messages found in the request body\",\n                True,\n            )\n\n            # Add response message\n            error_message = \"No messages found in the request body\"\n            body[\"messages\"] = body.get(\"messages\", []) + [\n                {\"role\": \"assistant\", \"content\": error_message}\n            ]\n            return {\"error\": error_message}\n\n        # Extract the latest question\n        last_message = messages[-1]\n        if last_message.get(\"role\") != \"user\":\n            await self.emit_status(\n                __event_emitter__,\n                \"error\",\n                \"Last message is not from user\",\n                True,\n            )\n            error_message = \"The last message must be from a user\"\n            body[\"messages\"].append(\n                {\"role\": \"assistant\", \"content\": error_message}\n            )  # NOQA\n            return {\"error\": error_message}\n\n        # Extract content from the last message\n        question_parts = last_message.get(\"content\", \"\")\n        # Pass the content to _extract_question which now handles both formats\n        question = self._extract_question(question_parts)\n\n        # Extract image URLs if present\n        image_urls = []\n        if isinstance(question_parts, list):\n            for item in question_parts:\n                if (\n                    item.get(\"type\") == \"image_url\"\n                    and \"image_url\" in item\n                    and \"url\" in item[\"image_url\"]\n                ):\n                    image_urls.append(item[\"image_url\"][\"url\"])\n\n        # If no question content found\n        if not question.strip() and not image_urls:\n            await self.emit_status(\n                __event_emitter__,\n                \"warning\",\n                \"Empty question received\",\n                True,\n            )\n            error_message = \"Please provide a non-empty question\"\n            body[\"messages\"].append(\n                {\"role\": \"assistant\", \"content\": error_message}\n            )  # NOQA\n            return {\"error\": error_message}\n\n        try:\n            # Extract first message content for session ID\n            first_message_content = \"\"\n            if messages and messages[0].get(\"content\"):\n                first_message_content = messages[0][\"content\"]\n\n            # Create session ID\n            session_id = self._create_session_id(\n                __user__, first_message_content\n            )  # NOQA\n\n            # Prepare the payload\n            payload = {\"sessionId\": session_id}\n            payload[self.valves.input_field] = question\n\n            # Add user info if available\n            if __user__:\n                payload[\"user\"] = {\n                    \"id\": __user__.get(\"id\", \"anonymous\"),\n                    \"name\": __user__.get(\"name\", \"\"),\n                    \"email\": __user__.get(\"email\", \"\"),\n                }\n\n            # Get headers\n            headers = {\n                \"Authorization\": f\"Bearer {self.valves.workflow_bearer_token}\",\n                \"Content-Type\": \"application/json\",\n            }\n\n            # Get the appropriate webhook URL\n            webhook_url = self.get_webhook_url()\n\n            # Log message content type\n            if image_urls:\n                logger.info(\n                    f\"Calling n8n webhook at: {webhook_url} \"\n                    f\"with text and {len(image_urls)} images\"\n                )\n            else:\n                logger.info(f\"Calling n8n webhook at: {webhook_url} with text only\")\n\n            # Try request with retries\n            n8n_response: Optional[str] = None\n            retry_count = 0\n            last_error: Optional[Exception] = None\n\n            while retry_count <= self.valves.max_retries:\n                try:\n                    await self.emit_status(\n                        __event_emitter__,\n                        \"info\",\n                        f\"Attempt {retry_count + 1}/\" f\"{self.valves.max_retries + 1}\",\n                        False,\n                    )\n\n                    # Use httpx for async HTTP request\n                    if image_urls:\n                        # When images are present, use form data instead of JSON\n                        form_data = {}\n                        files = []\n\n                        # Add text fields to form data\n                        form_data[\"sessionId\"] = session_id\n                        form_data[self.valves.input_field] = question\n\n                        # Add image files directly from image_urls\n                        for idx, image_url in enumerate(image_urls):\n                            # Handle data URLs\n                            if image_url.startswith(\"data:\"):\n                                # Extract mime type and content\n                                mime_type = image_url.split(\";\")[0].split(\":\")[1]\n                                file_ext = (\n                                    \".jpg\"\n                                    if \"jpeg\" in mime_type\n                                    else \".\" + mime_type.split(\"/\")[-1]\n                                )\n                                try:\n                                    # Extract base64 content\n                                    encoded_data = image_url.split(\",\")[1]\n                                    image_data = base64.b64decode(encoded_data)\n                                    # Add to files list for multipart upload\n                                    files.append(\n                                        (\n                                            f\"image_{idx}\",\n                                            (\n                                                f\"image_{idx}{file_ext}\",\n                                                io.BytesIO(image_data),\n                                                mime_type,\n                                            ),\n                                        )\n                                    )\n                                    logger.debug(f\"Added image_{idx} from data URL\")\n                                except Exception as e:\n                                    logger.error(\n                                        f\"Failed to process image data URL: {str(e)}\"\n                                    )\n\n                        # Update content type for multipart/form-data\n                        # (don't specify it, httpx will set it automatically)\n                        form_headers = {\n                            \"Authorization\": f\"Bearer {self.valves.workflow_bearer_token}\"\n                        }\n\n                        # Send multipart/form-data request\n                        response = await self._http_client.post(\n                            webhook_url,\n                            data=form_data,\n                            files=files,\n                            headers=form_headers,\n                        )\n                    else:\n                        # No images, use standard JSON request\n                        response = await self._http_client.post(\n                            webhook_url,\n                            json=payload,\n                            headers=headers,\n                        )\n\n                    # Check status code\n                    if response.status_code == 200:\n                        response_json = response.json()\n                        if self.valves.response_field in response_json:\n                            n8n_response = response_json[self.valves.response_field]\n                            break\n                        else:\n                            raise KeyError(\n                                f\"Response field '{self.valves.response_field}' \"\n                                \"not found in N8N response\"\n                            )\n                    else:\n                        raise httpx.HTTPStatusError(\n                            f\"Error: {response.status_code} - {response.text}\",\n                            request=response.request,\n                            response=response,\n                        )\n\n                except (httpx.HTTPError, KeyError) as e:\n                    last_error = e\n                    retry_count += 1\n                    if retry_count <= self.valves.max_retries:\n                        await self.emit_status(\n                            __event_emitter__,\n                            \"warning\",\n                            f\"Retry {retry_count}/{self.valves.max_retries}\",\n                            False,\n                        )\n                        time.sleep(1)  # Simple backoff\n\n            # If we've exhausted retries\n            if n8n_response is None and last_error is not None:\n                return await self._handle_http_error(last_error, __event_emitter__)\n\n            # Set assistant message with workflow reply\n            body[\"messages\"].append({\"role\": \"assistant\", \"content\": n8n_response})\n\n            await self.emit_status(__event_emitter__, \"info\", \"Complete\", True)\n            return n8n_response\n\n        except Exception as e:\n            return await self._handle_http_error(e, __event_emitter__)\n","meta":{"description":"iva_x1","manifest":{}},"is_active":true,"is_global":false,"updated_at":1753459776,"created_at":1752850835}]